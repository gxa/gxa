### Atlas Analytics Original Driver Functions
### Author: ostolop

(function() {

### Reads data from Atlas NetCDF file and returns an ExpressionSet
### Post-AEW migration TODOs:
### * NChannelSet
### * Multiple array designs
read.atlas.nc <<-
  function (filename, accnum = NULL) {
    
    require(ncdf)
    require(Biobase)
    require(gtools)

    nc = open.ncdf(filename)

    as = as.vector(get.var.ncdf(nc, "ASacc"))
    bs = as.vector(get.var.ncdf(nc, "BSacc"))
    b2a = fixMatrix(get.var.ncdf(nc, "BS2AS"), nRows = length(as), nCols = length(bs))

    de = as.vector(get.var.ncdf(nc, "DEacc"))
    bdc = fixMatrix(get.var.ncdf(nc, "BDC"), nRows = length(as), nCols = length(de))

    if ("EF" %in% names(nc$dim)) {
       ef = get.var.ncdf(nc, "EF")
       efv = get.var.ncdf(nc, "EFV")

       colnames(efv) = ef
       rownames(efv) = as
       efv = data.frame(efv)
       print(paste("Read in EFV:", nrow(efv), "x", ncol(efv)))
    }

    if ("SC" %in% names(nc$dim)) {
      sc = get.var.ncdf(nc, "SC")
      scv = get.var.ncdf(nc, "SCV")

      colnames(scv) = sc
      rownames(scv) = bs
      scv = data.frame(scv)
      print(paste("Read in SCV:", nrow(scv), "x", ncol(scv)))
    }

    # deacc = get.var.ncdf(nc, "DEacc")
    gn = get.var.ncdf(nc, "GN")

    # make de's unique
    #de[de == 0] <- -(1:length(which(de == 0)))

    accnum = att.get.ncdf(nc,varid = 0,"experiment_accession")$value
    qt = att.get.ncdf(nc,varid = 0,"quantitationType")$value
    adacc = att.get.ncdf(nc,varid = 0,"ADaccession")$value
    adname = att.get.ncdf(nc,varid = 0,"ADname")$value

    close.ncdf(nc)

    bdc = replaceMissingValues(bdc)

    if (length(as) == 1) {
      bdc = matrix(bdc, nrow = length(de))
      b2a = matrix(b2a, nrow = 1)
    } else {
      bdc = t(bdc)
    }
    rownames(bdc) = de
    colnames(bdc) = as

    rownames(b2a) = as
    colnames(b2a) = bs

    print(paste("Read in", accnum))
    print(paste("Read in BDC:", nrow(bdc), "x", ncol(bdc)))


    ncinfo = unlist(strsplit(basename(filename),"_|[.]"))
    exptid = ncinfo[1]
    arraydesignid = ncinfo[2]

    if (exists("efv")) {
      efscv <- efv
    } else {
      efscv <- data.frame(row.names=as)
    }

    if (1 == 0 && exists("scv")) {
        for(sc in colnames(scv)) {
            scvj <- as.factor(unlist(lapply(rownames(b2a), function(assayid)
                                      paste(unique(scv[colnames(b2a)[as.logical(b2a[assayid,])],sc]),
                                       sep = ",", collapse = "|"))))

            ef <- sub("bs_","ba_",sc)
             if( !identical(efscv[[ef]], scvj)) {
                       efscv[[sc]] <- scvj
               print(paste("scvj = ", scvj))
             }
        }
    }

    fDataFrame = data.frame(gn = gn,de = de) #, deacc = deacc)
    fData = new("AnnotatedDataFrame", data = fDataFrame)
    featureNames(fData) = de
    pData = new("AnnotatedDataFrame", data = efscv)

    if(exists("scv")) {
      scData = new("AnnotatedDataFrame", data = scv)
    }

    eData = new("MIAME",
      other = list(accession = accnum,
        experimentid = exptid,
        arraydesignid = arraydesignid,
        qt = qt,
        arraydesignaccnum = adacc,
        arraydesignname = adname
        )
      )

    if (exists("scv")) {
      attr(eData, "scv") <- scv
    }
    attr(eData, "b2a") <- b2a

    aData <- assayDataNew(storage.mode = "lockedEnvironment", exprs = bdc)
    featureNames(aData) <- de
    sampleNames(aData) <- as

    print(paste("Computed phenoData for", paste(varLabels(pData),collapse = ", "), nrow(pData), "x", ncol(pData)))
    return(new("ExpressionSet", assayData = aData, phenoData = pData, featureData = fData, experimentData = eData))
  }

### Log function that does not return NAs
log2.safe <-
  function(x,log = T) {
    if (!log)
      return(x)

    tmp = log2(x)
    tmp[!(is.finite(tmp) | is.na(x))] <- 0
    tmp
}

### function to check if factor value is empty
isEmptyEFV <- function(value) return (is.null(value) || value == "" || value == "(empty)")

### Omnibus one-way ANOVA (with moderated t) F-statistic computation
fstat.eset <-
  function(eset, design = NULL, varLabel = NULL,lg = FALSE) {
    if (is.null(design) && !is.null(varLabel)) {
      print(paste("Calculating design matrix for", varLabel))
        design = model.matrix(as.formula(paste("~0+", varLabel)), data = eset)
    }

    if (lg == TRUE) {
        exprs(eset)<-log2.safe(exprs(eset))
    }

    print("Fitting model...")
    fit = lmFit(eset,design)

    # print("Re-fitting model to ANOVA contrasts...")
    # pairs = design.pairs(colnames(design))
    # cfit = contrasts.fit(fit,pairs)

    # print("Moderating...")
    # cfit = eBayes(cfit)
    fit = eBayes(fit)

    # fit$F = cfit$F
    # fit$F.p.value = cfit$F.p.value

    return(fit)
}

### Moderated t one-way ANOVA post-hoc testing with global FDR adjustment
allupdn <-
  function (eset, alpha = 0.01, evars = varLabels(eset) ) {

    require(limma)

    exprs = exprs(eset)
    if (max(exprs,na.rm = TRUE) > 1000 && min(exprs, na.rm = TRUE) >= 0) {
      print("Taking log2 of the expression matrix")
      exprs(eset) = log2.safe(exprs)
    }

    allFits = list()

    for(varLabel in evars){
      try({
        print(paste("Calculating lmFit and F-stats for", varLabel))

        nonEmptyFactorValues = which(!sapply(eset[[varLabel, exact = TRUE]], isEmptyEFV))

        esetForVariable = eset[, nonEmptyFactorValues]
        esetForVariable[[varLabel, exact = TRUE]] = factor(esetForVariable[[varLabel, exact = TRUE]])

        numVariableFactorLevels <- nlevels(esetForVariable[[varLabel, exact=TRUE]])
        if (numVariableFactorLevels == ncol(exprs(esetForVariable)) || numVariableFactorLevels < 2) {
          print("Can't compute statistics for poorly conditioned data: too few or too many factor levels.")
          next
        }

        thisFit = fstat.eset(esetForVariable, varLabel = varLabel)

        n = ncol(thisFit$design)
        cm = diag(n) - 1/n

        contr.fit = contrasts.fit(thisFit, cm)
        contr.fit = eBayes(contr.fit)

        dec = decideTests(contr.fit, method = "global", adjust.method = "fdr")
        colnames(dec) = levels(esetForVariable[[varLabel, exact = TRUE]])

        thisFit$boolupdn = dec
        thisFit$contr.fit = contr.fit

        allFits[[varLabel]] = thisFit
        print("Done.")
      })
    }

    allFits
}

### Atlas analytics processing driver: read the data, compute the linear fit, post-hoc test, adjust and write to tab-delim files
process.atlas.nc<-
  function (nc) {

    eset = read.atlas.nc(nc)
    info = otherInfo(experimentData(eset))
    proc = allupdn(eset)

    print("Writing out the results")
    for (varLabel in varLabels(eset)) {
      if (!is.null(proc[[varLabel, exact = TRUE]]$contr.fit)) {
        fitfile <- paste(info$accession, "_", info$experimentid, "_", info$arraydesignid, "_", varLabel, "_", "fit.tab", sep = "")
        tab <- list()
        tab$A <- proc[[varLabel, exact = TRUE]]$Amean
        # tab$Coef <- proc[[varLabel, exact = TRUE]]$contr.fit$coef
        tab$t <- proc[[varLabel, exact = TRUE]]$contr.fit$t
        tab$p.value <- as.matrix(proc[[varLabel, exact = TRUE]]$contr.fit$p.value)

        pv = tab$p.value
        o = !is.na(tab$p.value)
        pv[o] = p.adjust(pv[o], method = "fdr")

        tab$p.value.adj = pv
        tab$Res <- unclass(proc[[varLabel, exact = TRUE]]$boolupdn)
        tab$F <- proc[[varLabel, exact = TRUE]]$F
        tab$F.p.value <- proc[[varLabel, exact = TRUE]]$F.p.value
        tab$F.p.value.adj = proc[[varLabel, exact = TRUE]]$F.p.value.adj
        tab$Genes <- proc[[varLabel, exact = TRUE]]$genes
        tab <- data.frame(tab, check.names = FALSE)
        write.table(tab, file = fitfile, quote = FALSE, row.names = FALSE, sep = "\t")
        print(paste("Wrote",fitfile))
      }
    }
  }

### Atlas analytics, returns instead of writing
computeAnalytics <<-
  function (nc) {
    e <- try({
      eset = read.atlas.nc(nc)
      ncd = open.ncdf(nc, write = TRUE)

      if (dim(eset)[2] == 1) {
        return(sapply(varLabels(eset), function(i) "NOK"))
      }

      proc = allupdn(eset)

      uVAL = get.var.ncdf(ncd, "uVAL")

      # initialize tstat and pval to NA
      tstat = matrix(NA, ncol = length(uVAL), nrow = nrow(eset)); #t(get.var.ncdf(ncd, "TSTAT"))
      pval = matrix(NA, ncol = length(uVAL), nrow = nrow(eset)); #t(get.var.ncdf(ncd, "PVAL"))

      colnames(tstat) <- make.names(uVAL)
      colnames(pval) <- make.names(uVAL)

      result <- sapply(varLabels(eset),
                       function(varLabel) {
                         print(paste("Processing",varLabel))
                         if (is.null(proc[[varLabel, exact = TRUE]]$contr.fit)) {
                           return("NOK")
                         }

                         tab <- list()
                         tab$A <- proc[[varLabel, exact = TRUE]]$Amean
                         tab$t <- proc[[varLabel, exact = TRUE]]$contr.fit$t
                         tab$p.value <- as.matrix(proc[[varLabel, exact = TRUE]]$contr.fit$p.value)

                         pv = tab$p.value
                         o = !is.na(tab$p.value)
                         pv[o] = p.adjust(pv[o], method = "fdr")

                         tab$p.value.adj = pv
                         tab$Res <- unclass(proc[[varLabel, exact = TRUE]]$boolupdn)

                         # tab$F <- proc[[varLabel, exact = TRUE]]$F
                         # tab$F.p.value <- proc[[varLabel, exact = TRUE]]$F.p.value
                         # tab$F.p.value.adj = proc[[varLabel, exact = TRUE]]$F.p.value.adj

                         tab$Genes <- proc[[varLabel, exact = TRUE]]$genes

                         colnames(tab$Res) <- make.names(paste(varLabel,colnames(tab$Res),sep = "||"))

                         colnames(tab$t) <- colnames(tab$Res)
                         colnames(tab$p.value.adj) <- colnames(tab$Res)

                         tstat[,which(colnames(tstat) %in% colnames(tab$t))] <<- tab$t[,colnames(tstat)[which(colnames(tstat) %in% colnames(tab$t))]]
                         pval[,which(colnames(pval) %in% colnames(tab$p.value.adj))] <<- tab$p.value.adj[,colnames(pval)[which(colnames(pval) %in% colnames(tab$p.value.adj))]]

                         return("OK")
                       })

      print(paste("Writing tstat and pval to NetCDF:", ncol(tstat), "x", nrow(tstat)))
      put.var.ncdf(ncd, "TSTAT", t(tstat))
      put.var.ncdf(ncd, "PVAL", t(pval))

      efsc = get.var.ncdf(ncd, "EF")
      #efsc = get.var.ncdf(ncd, "EFSC")
      
      close.ncdf(ncd)

      names(result) <- efsc

      updateStatOrder(nc)

      return(result)
    })

    return(e)
  }

# Computes and saves the order of design elements for each statfilter value
updateStatOrder <<-
  function(filename) {
    
    ncd <- open.ncdf(filename, write = TRUE)
    on.exit(close.ncdf(ncd))

    nCols <- length(get.var.ncdf(ncd, "uVAL"))
    pval <- transposeMatrix(get.var.ncdf(ncd, "PVAL"), nCols)
    tstat <- transposeMatrix(get.var.ncdf(ncd, "TSTAT"), nCols)
    gn <- get.var.ncdf(ncd, "GN")

    print(paste("T(rows:", nrow(tstat), "cols:", ncol(tstat), ")"))
    print(paste("P(rows:", nrow(pval), "cols:", ncol(pval), ")"))

    tstat <- replaceMissingValues(tstat)
    pval <- replaceMissingValues(pval)

    # find rows of zero genes and NA values
    zeroGnIdxs <- (gn == 0)
    print(paste("length( Zero GN rows ):", length(which(zeroGnIdxs))))

    naIdxsT <- apply(is.na(tstat), 1, all)
    naIdxsP <- apply(is.na(pval), 1, all)
    naIdxs <- apply(cbind(naIdxsT, naIdxsP), 1, function(x){ x[1] || x[2]})
    print(paste("length( NA rows ):", length(which(naIdxsP))))

    allBadIdxs <- apply(cbind(naIdxs, zeroGnIdxs), 1, function(x){ x[1] || x[2] })
    
    for (statfilter in c("ANY", "UP_DOWN", "UP", "DOWN", "NON_D_E")) {
      ifelse (statfilter == "ANY",
              badIdxs <- zeroGnIdxs,
              badIdxs <- allBadIdxs
      )

      tstatGood <- filterMatrix(tstat, 1, !badIdxs)
      pvalGood <- filterMatrix(pval, 1, !badIdxs)

      print(paste("Sorting/filtering tstat and pval by filter:", statfilter))
      idxs <- c(1:nrow(tstat))
      idxs[badIdxs] <- NA

      res <- orderByStatfilter(statfilter, tstatGood, pvalGood)
      print(paste("length( result ):", length(res$rowidxs)))

      initial <- idxs[!is.na(idxs)]
      filtered <- initial[res$rowidxs]
      filtered <- filtered[1:nrow(tstat)]
      filtered[is.na(filtered)] <- 0
      vname <- paste("ORDER_", statfilter, sep = "")

      tryCatch({
        print(paste(vname, "written..."))
        put.var.ncdf(ncd, vname, filtered)
      }, error = function(e) print(e))
    }
    return("OK")
  }

replaceMissingValues <<-
  function(m) {
    m[m <= -1e6] = NA
    m[m == 9.969209968386869e36] = NA # set to NA the default float fill value
    return(m)
  }

transposeMatrix <<-
  function(m, nCols, nRows) {
    if (is.matrix(m)) {
       return(t(m))
    }
    ifelse(nCols > 0, out <- matrix(m, ncol = nCols), out <- matrix(m, nrow = nRows))
    return(out)
  }

fixMatrix <<-
  function(m, nCols, nRows) {
     if (is.matrix(m)) {
       return(m)
     }
     ifelse(nCols > 0, out <- matrix(m, ncol = nCols), out <- matrix(m, nrow = nRows))
     return(out)
  }

filterMatrix <<-
    function(m, direction = 1, filter) {
        byRows <- (direction == 1)
        byColummns <- (direction == 2)

        nCols <- ncol(m)
        nRows <- nrow(m)

        m2 = m;
        if (byRows) {
            m2 <- m[filter, ]
            m2 <- fixMatrix(m2, nCols = nCols)
        } else if (byColummns) {
            m2 <- m[ ,filter]
            m2 <- fixMatrix(m2, nRows = nRows)
        }
        return(m2)
    }

### Compute a design matrix for making all possible pairwise comparisons (one-way ANOVA F).
design.pairs <-
  function(levels) {
    makeContrasts(contrasts = combn(levels, 2, paste, collapse = '-'),levels = levels)
  }

### Sorts T and P values by statfilter.
orderByStatfilter <-
  function(statfilter, tstat, pval) {
    nrows <- nrow(pval)

    minpvals <- rep(-1, nrows)
    maxtstats <- rep(-1, nrows)
    maxtstatidxs <- rep(-1, nrows)

    f.tstat <- tstat
    f.pval <- pval

    max.safe <- function(x)ifelse(all(is.na(x)), 1, which.max(x))
      
    if (statfilter == "ANY") {
      maxtstatidxs <- apply(abs(f.tstat), 1, max.safe)

    } else if (statfilter == "UP_DOWN") {
      f.pval[pval > 0.05] <- 1
      f.tstat[pval > 0.05] <- 0
      maxtstatidxs <- apply(abs(f.tstat), 1, max.safe)

    } else if (statfilter == "UP") {
      f.pval[pval > 0.05 | tstat < 0] <- 1
      f.tstat[pval > 0.05 | tstat < 0] <- 0
      maxtstatidxs <- apply(f.tstat, 1, max.safe)

    } else if (statfilter == "DOWN") {
      f.pval[pval > 0.05 | tstat > 0] <- 1
      f.tstat[pval > 0.05 | tstat > 0] <- 0
      maxtstatidxs <- apply(-f.tstat, 1, max.safe)

    } else if(statfilter == "NON_D_E") {
      f.pval[pval <= 0.05] <- 1
      f.tstat[pval <= 0.05] <- 0
      maxtstatidxs <- apply(abs(f.tstat), 1, max.safe)
    }

    for (i in seq_along(maxtstatidxs)) {
      minpvals[i] <- f.pval[i, maxtstatidxs[i]]
      maxtstats[i] <- f.tstat[i, maxtstatidxs[i]]
    }

    idxs <- order(minpvals, -abs(maxtstats), na.last = TRUE)

    if (statfilter != 'ANY') {
      idxs <- idxs[which(minpvals[idxs] < 1 & maxtstats[idxs] != 0)]
    }

    return(
      data.frame(
        rowidxs = idxs,
        colidxs = maxtstatidxs[idxs],
        minpvals = minpvals[idxs],
        maxtstats = maxtstats[idxs]
      )
    )
  }

### Returns T and P values for selected genes and factors.
### If nothing is specified it returns the best genes arcording the statfilter (default is ANY).
find.best.design.elements <<-
  function(ncdf, gnids = NULL, ef = NULL, efv = NULL, statfilter = c('ANY','UP_DOWN','DOWN','UP','NON_D_E'), statsort = "PVAL", from = 1, rows = 10) {

    # info = sessionInfo()
    # print(info)

    require(ncdf)

    options(digits.secs = 6)
    print(Sys.time())
   
    from <- max(1, from)
    to <- (from + rows -1)
    totalRowCount <- 0
    
    statfilter = match.arg(statfilter)

    nc <- open.ncdf(ncdf)

    gn <- get.var.ncdf(nc, "GN")

    deAcc <- get.var.ncdf(nc, "DEacc")

    wde <- which(gn > 0)

    uval <- tryCatch(nc$dim$uVAL$vals, error = function(e) NULL)
    if (is.null(uval)) {
        print(paste("Outdated ncdf - no uVAL variable present; reading uEFV..."))
        uval <- nc$dim$uEFV$vals
    }
    wuval <- c()

    if ((!is.null(ef) && ef != "") && isEmptyEFV(efv)) {
      wuval <- grep(paste(ef,"||",sep = ""), uval, fixed = TRUE)

    } else if ((!is.null(ef) && ef != "") && !isEmptyEFV(efv)) {
      efv <- paste(ef, efv, sep = "||")
      wuval <- which(uval %in% efv)

    } else {
      wuval <- rep(1:length(uval))
    }

    if (!is.null(gnids) && gnids != "") {
      wde <- which(gn %in% gnids)
      
    } else if (length(wuval) == length(uval)) { # if no params
      rowOrder <- tryCatch(get.var.ncdf(nc, paste("ORDER_", statfilter, sep = "")), error = function(e) NULL)
      if (!is.null(rowOrder)) {
         rowOrder <- rowOrder[rowOrder > 0]
         to <- min(to, length(rowOrder))
         from <- min(from, to)
         wde <- rowOrder[from:to]
         from <- 1
         totalRowCount <- length(rowOrder)
      }
    }

    tstat <- matrix(nrow = length(wde), ncol = length(wuval))
    pval <- matrix(nrow = length(wde), ncol = length(wuval))

    if (length(wuval) < length(uval)) {
      for (i in seq_along(wuval)) {
        tstat[,i] <- get.var.ncdf(nc, "TSTAT", start = c(wuval[i],1), count = c(1,-1))[wde]
        pval[,i] <- get.var.ncdf(nc, "PVAL", start = c(wuval[i],1), count = c(1,-1))[wde]
      }
    } else {
      if (length(wde) < 0.2 * nc$dim$DE$len) {
        for (i in seq_along(wde)) {
          tstat[i,] <- get.var.ncdf(nc, "TSTAT", start = c(1,wde[i]), count = c(-1,1))
          pval[i,] <- get.var.ncdf(nc, "PVAL", start = c(1,wde[i]), count = c(-1,1))
        }
      } else {
        tstat <- transposeMatrix(get.var.ncdf(nc, "TSTAT"))[wde,]
        pval <- transposeMatrix(get.var.ncdf(nc, "PVAL"))[wde,]
      }
    }
    close(nc)
    print(Sys.time())

    tstat <- replaceMissingValues(tstat)
    pval <- replaceMissingValues(pval)

    idxs <- c()
    uvalidxs <- c()
    minpvals <- c()
    maxtstats <- c()
    totalCount <- 0
    
    if (nrow(tstat) && ncol(tstat) > 0) {
      if (statfilter != "ANY") {
        idxsT <- apply(!is.na(tstat), 1, any)
        idxsP <- apply(!is.na(pval), 1, any)
        idxsBoth <- apply(cbind(idxsT, idxsP), 1, function(x){x[1]&x[2]})

        pval <- filterMatrix(pval, 1, idxsBoth)
        tstat <- filterMatrix(tstat, 1, idxsBoth)
      }
      
      to <- min(nrow(pval), to)

      result <- orderByStatfilter(statfilter, tstat, pval);
      residxs <- result$rowidxs

      if (length(residxs) > 0) {
        to <- min(length(residxs), to)
        idxs <- result$rowidxs[from:to]
        uvalidxs <- result$colidxs[from:to]
        minpvals <- result$minpvals[from:to]
        maxtstats <- result$maxtstats[from:to]
        totalCount <- length(result$rowidxs)
      }
    }

    uvals <- c()

    for (i in seq_along(uvalidxs)) {
      if (length(wuval) > 1) {
        uvals[i] <- uval[wuval[uvalidxs[i]]]
      } else {
        uvals[i] <- uval[wuval]
      }
    }

    print(Sys.time())

    # minpvals[1:length(minpvals)] <- NA
    # maxtstats[1:length(maxtstats)] <- NA

    uvalMatrix = sapply(c, function(str) { strsplit(str, "\\|\\|")[[1]] })

    res <-  data.frame(
        deindexes = as.integer(wde[idxs]),
        deaccessions = as.character(deAcc[wde[idxs]]),
        geneids = as.integer(gn[wde[idxs]]),
        minpvals = minpvals,
        maxtstats = maxtstats,
        uvalNames = uvalMatrix[1,],
        uvalValues = uvalMatrix[2,]
      )
    attr(res, "total") <- as.integer(max(totalRowCount, totalCount))
    return(res)
 }
})()

